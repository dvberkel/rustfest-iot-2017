<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./rustfest.html"><strong>1.</strong> Foreward - RustFest 2017 Workshop</a></li><li><a href="./setup/intro.html"><strong>2.</strong> Development Environment Setup</a></li><li><ul class="section"><li><a href="./setup/raspi_self.html"><strong>2.1.</strong> Raspberry Pi Setup</a></li><li><a href="./setup/tock_os.html"><strong>2.2.</strong> Tock OS Setup</a></li></ul></li><li><strong>3.</strong> Background Info</li><li><ul class="section"><li><a href="./background/iot.html"><strong>3.1.</strong> The Internet of Things</a></li><li><a href="./background/ble.html"><strong>3.2.</strong> Bluetooth Low Energy</a></li><li><a href="./background/mqtt_and_other.html"><strong>3.3.</strong> MQTT and other IoT Protocols</a></li><li><a href="./background/cross_compiling.html"><strong>3.4.</strong> Cross Compilation</a></li><li><a href="./background/raspi.html"><strong>3.5.</strong> Raspberry Pi and Embedded Linux</a></li><li><a href="./background/tock_os.html"><strong>3.6.</strong> The Hail Board and Tock OS</a></li></ul></li><li><a href="./tock_os/intro.html"><strong>4.</strong> Tock OS Work</a></li><li><strong>5.</strong> Raspberry Pi Work</li><li><ul class="section"><li><a href="./raspi/hello_world.html"><strong>5.1.</strong> Hello, World!</a></li><li><a href="./raspi/bluetooth.html"><strong>5.2.</strong> Talking with Bluetooth</a></li><li><a href="./raspi/geeny.html"><strong>5.3.</strong> Talking to the Cloud</a></li><li><a href="./raspi/integration.html"><strong>5.4.</strong> Putting it together</a></li><li class="spacer"></li></ul></li><li>2017 James Munns, Niklas Adolfsson, Amit Levy</li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#iot-workshop---rustfest-z체rich-2017" id="iot-workshop---rustfest-z체rich-2017"><h1>IoT Workshop - Rustfest Z체rich 2017</h1></a>
<p>This workshop will be a hands-on training for developing bare-metal and embedded Linux systems using Rust. You will use Tock-OS to create a low power Bluetooth sensor node on a Hail development board, and build a Smart IoT Gateway using a Raspberry Pi 3. Training and hardware will be provided for developing Rust software on both Microcontroller and Embedded Linux based systems. Attendees will start with a working base example for both devices, and can build new functionality from there. Some experience with Rust and either (or both) Microcontroller or Linux systems is recommended.</p>
<a class="header" href="print.html#the-schedule" id="the-schedule"><h2>The Schedule</h2></a>
<p>This workshop will be broken in to four major parts, each lasting about an hour with breaks:</p>
<ol>
<li>Introduction and Background Information</li>
<li>Develop Microcontroller Software with TockOS</li>
<li>Develop Gateway Software on Embedded Linux</li>
<li>Additional Challenges and Free Work time</li>
</ol>
<a class="header" href="print.html#the-hardware" id="the-hardware"><h2>The Hardware</h2></a>
<p>Today, we will be working with two pieces of hardware:</p>
<blockquote>
<p>A <a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/">Raspberry Pi 3</a> board, acting as an IoT Smart Gateway</p>
</blockquote>
<p align="center">
<img title="Raspberry Pi 3 with case" src="assets/raspberry_pi_3.jpg">
</p>
<blockquote>
<p>A <a href="https://www.tockos.org/blog/2017/introducing-hail/">Tock OS Hail</a> board, acting as a low power IoT device</p>
</blockquote>
<p align="center">
<img title="TockOS Hail Board" src="assets/hail_board.jpg">
</p>
<a class="header" href="print.html#the-speakers" id="the-speakers"><h2>The Speakers</h2></a>
<blockquote>
<p>James Munns is an Embedded Engineer who has worked on systems ranging from Safety Critical Avionics to Rapidly Prototyped IoT systems. During the day James works at Geeny in Berlin, developing frameworks and tools for IoT Embedded Developers.</p>
</blockquote>
<p align="center">
<img title="James Munns" src="assets/james.jpg">
</p>
<blockquote>
<p>Niklas Adolfsson is embedded software developer at Cybercom in Sweden. He received a B.S. degree at in Electrical at University of Bor책s and is currently pursing a MSc. in Computer Science at Chalmers University. He is also a contributor to Tock and has worked as a dependability engineer at SP Technical Research Institute of Sweden.</p>
</blockquote>
<p align="center">
<img title="Niklas Adolfsson" src="assets/niklas.jpg">
</p>
<a class="header" href="print.html#development-environment-setup" id="development-environment-setup"><h1>Development Environment Setup</h1></a>
<blockquote>
<p>NOTE: These steps are only necessary if you are not using the provided VM.</p>
<p>These were all steps necessary for setting up the Xubuntu 16.04 VM.</p>
</blockquote>
<pre><code class="language-bash"># Add repository for tock compiler
sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa
sudo apt-get update

# Install all dependencies
sudo apt-get install -y \
    ca-certificates \
    cmake \
    curl \
    g++-arm-linux-gnueabihf \
    gcc \
    gcc-arm-embedded \
    gedit \
    git \
    libc6-dev \
    libc6-dev-armhf-cross \
    make pkg-config \
    mosquitto-client \
    multistrap \
    python3 \
    python3-pip \
    wget

# Patch multistrap
sudo sed -i &quot;s/\$forceyes//g&quot; /usr/sbin/multistrap

# Provide python
sudo ln -s /usr/bin/python3 /usr/bin/python

# Populate multistrap configuration

cat &lt;&lt; EOF &gt; ./multistrap.conf
[General]
arch=armhf
noauth=true
unpack=true
debootstrap=Debian
aptsources=Debian

[Debian]
source=http://ftp.debian.org/debian
suite=stable
packages=libdbus-1-dev libssl-dev openssl

EOF

# Perform multistrap setup
sudo multistrap -a armhf -d /raspi_stretch -f ./multistrap.conf

# Link a few dependencies to match compilation expectations
sudo ln -s /raspi_stretch/lib/arm-linux-gnueabihf/libsystemd.so.0 /raspi_stretch/lib/arm-linux-gnueabihf/libsystemd.so
sudo ln -s /raspi_stretch/usr/include/arm-linux-gnueabihf/openssl/opensslconf.h /raspi_stretch/usr/include/openssl/opensslconf.h

# Allow the SYSROOT to be seen/owned by the main user
sudo chown -R rustfest /raspi_stretch/

# Setup file used when cross compiling to the Raspberry Pi

cat &lt;&lt; EOF &gt; ~/pi-crossenv
# This is where we have installed our fake raspberry pi debian system
export SYSROOT=/raspi_stretch
export RPI_USR_LIB_DIR=${SYSROOT}/usr/lib/arm-linux-gnueabihf
export RPI_LIB_DIR=${SYSROOT}/lib/arm-linux-gnueabihf

# Inform Cargo and Rustc that we are cross compiling, as well as some configuration
# specific to our current use cases
export CARGO_TARGET_ARMV7_UNKNOWN_LINUX_GNUEABIHF_LINKER=arm-linux-gnueabihf-gcc
export CC_armv7_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc
export CXX_armv7_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++
export OPENSSL_INCLUDE_DIR=/raspi_stretch/usr/include
export OPENSSL_LIB_DIR=/raspi_stretch/usr/lib/arm-linux-gnueabihf
export OPENSSL_DIR=/raspi_stretch/usr/lib/ssl
export PKG_CONFIG_PATH=${RPI_USR_LIB_DIR}/pkgconfig
export PKG_CONFIG_LIBDIR=${RPI_USR_LIB_DIR}/pkgconfig:/usr/share/pkgconfig
export PKG_CONFIG_SYSROOT_DIR=${SYSROOT}
export PKG_CONFIG_ALLOW_CROSS=1
export RUSTFLAGS=&quot;-L ${RPI_USR_LIB_DIR} -L ${RPI_LIB_DIR} -lsystemd&quot;

EOF

# Install rust and friends
curl https://sh.rustup.rs -sSf | sh
rustup component add rust-src
rustup install nightly-2017-09-20
rustup target add armv7-unknown-linux-gnueabihf
cargo install xargo
</code></pre>
<a class="header" href="print.html#raspberry-pi-setup" id="raspberry-pi-setup"><h1>Raspberry Pi Setup</h1></a>
<blockquote>
<p>This setup has already been done for you if you are attending the workshop. These steps are only necessary if you are replicating the setup at home.</p>
</blockquote>
<p>The software on our Raspberry Pi is based on the <code>2017-09-07</code> version of the &quot;Raspbian Stretch Lite&quot; image, which can be <a href="https://www.raspberrypi.org/downloads/raspbian/">found here</a>.</p>
<p>Additionally, the following packages were installed via <code>apt-get</code>:</p>
<ul>
<li><code>libssl-dev</code></li>
<li><code>libdbus-1-dev</code></li>
</ul>
<a class="header" href="print.html#tock-os-setup" id="tock-os-setup"><h1>Tock OS Setup</h1></a>
<p>All steps necessary for setting up the Tock OS environment are performed in the <a href="setup/intro.html">main environment setup</a>. More information can be seen on the <a href="https://github.com/helena-project/tock/blob/master/doc/Getting_Started.md">Official Tock Getting Started Guide</a>.</p>
<a class="header" href="print.html#the-internet-of-things" id="the-internet-of-things"><h1>The Internet of Things</h1></a>
<a class="header" href="print.html#what-is-the-internet-of-things" id="what-is-the-internet-of-things"><h2>What is the Internet of Things?</h2></a>
<p>Generally, the Internet of Things covers devices that are now capable of communicating with other systems, either locally (like Bluetooth), or globally, via the Internet. People want to control items in the physical world similarly to how they are able to control and interconnect software</p>
<a class="header" href="print.html#where-did-it-come-from" id="where-did-it-come-from"><h3>Where did it come from?</h3></a>
<p>IoT has risen from two main sources:</p>
<ol>
<li>Industrial machinery that was &quot;smart&quot; before, but had little or no device to device connectivity</li>
<li>Consumer devices, which are now cheap enough or resource efficient enough to include a networked component</li>
</ol>
<p>As components used in devices like wireless routers and mobile phones have become more available, as well as cheaper, hardware developers have begun using them in other products, including IoT devices.</p>
<p>Around the same time, the maker movement, especially with the introduction of platforms like Arduino and the Raspberry Pi, have made embedded development much more accessible, both from a price perspective, as well as learning curve, and available resources.</p>
<p>We've now ended up with a new wave of embedded systems developers who are interested in the Internet of Things.</p>
<a class="header" href="print.html#why-is-rust-a-good-match-for-iot" id="why-is-rust-a-good-match-for-iot"><h2>Why is Rust a good match for IoT?</h2></a>
<p>Over the last 20 years or so, we've gotten <em>okay</em> at connecting computers to the Internet, as well as keeping them decently secure. This has happened through:</p>
<ul>
<li>Use of well known, actively developed components</li>
<li>Healthy respect for security updates and patches</li>
<li>Multiple layers of security, including isolation</li>
<li>Sane defaults</li>
<li>Memory safe languages (usually garbage collected)</li>
<li>Willingness to trade some performance for better security</li>
<li>Improved security implementation in hardware and software</li>
</ul>
<p>However on IoT devices, especially low end or battery powered devices, most developers are forced to minimize overhead. Many embedded systems and software were never originally designed to be Internet connected, let alone publicly available.</p>
<p>Rust allows us to move lots of the safety checks from runtime to compile time, allowing us to avoid some of the most common security holes such as buffer overflows, use after frees, etc. that are very common in protocol and parser implementations.</p>
<p>Additionally, Rust ships with Cargo, the default build tool and package manager for Rust development, which allows easier reuse of code.</p>
<p>Because Rust is based on LLVM, we have either full or partial support for some of the most common hardware used in IoT today, including:</p>
<ul>
<li>ARM Cortex-A</li>
<li>ARM Cortex-M</li>
<li>MIPS</li>
<li>x86[-64]</li>
</ul>
<a class="header" href="print.html#architecture" id="architecture"><h2>Architecture</h2></a>
<p align="center">
<img title="The Internet of Things, a basic diagram" src="assets/iot.svg">
</p>
<p>Since IoT covers such a wide range of topics and devices, different approaches are needed to solve different problems</p>
<a class="header" href="print.html#direct-nodes" id="direct-nodes"><h3>Direct Nodes</h3></a>
<p>Direct Nodes are devices that are capable of connecting directly to the Internet, typically over WiFi, GSM/Cell, or Ethernet. Since these communication methods are relatively high-power, direct nodes tend to either be wall-powered, or if battery powered, they connect infrequently to save battery life.</p>
<p>These could include devices running Linux, like a Raspberry Pi, or high end microcontroller systems, like the ESP32.</p>
<p>Speaking a full &quot;Internet Protocol&quot;, including components like SSL, IPv6, and more requires computational and memory resources that many device can't handle</p>
<p>Examples:</p>
<ul>
<li>Amazon Alexa</li>
<li>Smart TVs and other Appliances</li>
<li>Nest</li>
</ul>
<a class="header" href="print.html#indirect-nodes" id="indirect-nodes"><h3>Indirect Nodes</h3></a>
<p>For devices where power or capabilities prevent direct Internet access, the next most common kind of IoT device connects to the Internet with assistance from a more powerful device.</p>
<p>This could mean the device is equipped to use a low power interface, such as Zigbee, Bluetooth, 6LoWPan, or Thread, which are designed to be power efficient, and were designed with low resource devices in mind.</p>
<p>For protocols like 6LoWPan or Thread, a simple &quot;border router&quot; which translates transparently from the low power protocol to full IP can be used. For protocols which are significantly different from IP, a Smart Hub/Gateway is typically used. Gateways typically require more &quot;business logic&quot; to determine how to correctly route messages.</p>
<p>Examples:</p>
<ul>
<li>Bluetooth Fitness Trackers</li>
<li>Smart Light Bulbs</li>
<li>Temperature Sensors</li>
</ul>
<a class="header" href="print.html#border-routers-and-gateways" id="border-routers-and-gateways"><h3>Border Routers and Gateways</h3></a>
<p>As mentioned above, Border Routers and Gateways are used to assist connectivity of low power devices. Both of these devices share the same typical design:</p>
<ul>
<li>Wall powered</li>
<li>Ethernet, Cell, or WiFi connectivity</li>
<li>Low-power radios/interfaces (LPWAN, PAN) for communication with Indirect Nodes</li>
</ul>
<p>For border routers, little additional functionality may be necessary, other than converting from 6LoWPan to IPv6. These device function similarly to WiFi routers: transparently connecting the devices to the Internet.</p>
<p>For gateways, it is typically necessary to understand the devices that will be connected. This could be as simple as mapping local protocol constructs like Services and Characteristics to some kind of IP construct, such as URIs/endpoints.</p>
<p>Both of these devices may also be a &quot;Direct Node&quot; themselves, while also providing Border Router or Gateway functionality.</p>
<ul>
<li>&quot;Smart Hub&quot;/&quot;Smart Gateway&quot; devices</li>
<li>Thermostat that communicates with Temperature Sensors</li>
<li>Raspberry Pi running <a href="https://home-assistant.io/">Home Assistant</a></li>
</ul>
<a class="header" href="print.html#the-cloud" id="the-cloud"><h3>The Cloud</h3></a>
<ul>
<li>A central point for all devices to connect</li>
<li>Enables additional functionality, such as maintaining history, connecting dissimilar devices to each other</li>
</ul>
<p>Typically speaks device-friendly protocols such as MQTT, CoAP, LWM2M, etc., as well as protocols useful for browsers and apps, such as REST, Websockets, etc.</p>
<a class="header" href="print.html#bluetooth-low-energy" id="bluetooth-low-energy"><h1>Bluetooth Low Energy</h1></a>
<p>Bluetooth Low Energy (BLE) was integrated into the Bluetooth 4.0 specification in 2010. BLE reduced the typical power consumption for devices compared to Bluetooth Classic (Bluetooth 3.x and below), and provided a framework (GATT) that allowed implementation of common functionality, as well as implementation specific functionality.</p>
<p>Bluetooth has not typically been thought of as an IoT-specific technology, however the prevalence of hardware due to commercially successful products, as well as usage in Laptops and Phones, means that the barrier to entry for consumers is reduced. Additionally, Bluetooth 5 (introduced 2016) introduces additional capabilities, including extended range, higher data throughput, and better coexistence (allowing more simultaneous devices), making it a better fit for IoT applications.</p>
<a class="header" href="print.html#gatt" id="gatt"><h2>GATT</h2></a>
<p>The Generic Attribute Profile, or GATT, defines a system for Central Clients (e.g. a Mobile Phone or Laptop) to discover and interact with Peripheral Servers (e.g. a Bluetooth Fitness Device).</p>
<p>Servers may provide a set of standard functionality to allow interoperability with many Central devices, as well as expose manufacturer specific functionality.</p>
<a class="header" href="print.html#clients-and-servers" id="clients-and-servers"><h2>Clients and Servers</h2></a>
<p>With BLE, the Server broadcasts information about itself, allowing Clients to discover the Server, as well as what capabilities the Server offers. Clients can choose to connect to the Server, in order to obtain additional information, or to establish a secure communication channel.</p>
<a class="header" href="print.html#services-and-characteristics" id="services-and-characteristics"><h2>Services and Characteristics</h2></a>
<p>Functionality of BLE are exposed via Characteristics, which are identified with a 128-bit UUID, such as <code>0000c01d-c001-de30-cabb-785feabcd123</code>. These Characteristics are grouped into Services, which provide no functionality, but are a collection of related Characteristics. Services are also identified with a UUID, such as <code>00000001-c001-de30-cabb-785feabcd123</code>.</p>
<p>An example of this grouping might look like this:</p>
<ul>
<li>Bluetooth Server Peripheral
<ul>
<li>Service: <code>00000001-c001-de30-cabb-785feabcd123</code>
<ul>
<li>Characteristic: <code>0000da7a-c001-de30-cabb-785feabcd123</code></li>
<li>Characteristic: <code>0000c01d-c001-de30-cabb-785feabcd123</code></li>
<li>Characteristic: <code>0000cafe-c001-de30-cabb-785feabcd123</code></li>
</ul>
</li>
<li>Service: <code>0f050001-3225-44b1-b97d-d3274acb29de</code>
<ul>
<li>Characteristic: <code>0f050002-3225-44b1-b97d-d3274acb29de</code></li>
</ul>
</li>
<li>Service: <code>00001801-0000-1000-8000-00805f9b34fb</code>
<ul>
<li>Characteristic: <code>00002a05-0000-1000-8000-00805f9b34fb</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>When interacting with a BLE Server, all communication is made via Characteristics.</p>
<a class="header" href="print.html#standard-services" id="standard-services"><h3>Standard Services</h3></a>
<p>For common functionality standardized by the Bluetooth Special Interest Group (SIG), Services and Characteristics can be assigned a 16-bit Shorthand ID, which can be used instead of the full 128-bit UUID. The Bluetooth SIG maintains a list of defined <a href="https://www.bluetooth.com/specifications/gatt/services">Services</a> and <a href="https://www.bluetooth.com/specifications/gatt/characteristics">Characteristics</a>.</p>
<p>In the example above, the Service <code>00001801-0000-1000-8000-00805f9b34fb</code> is defined as a &quot;Generic Attribute&quot; service, which may be shortened as <code>0x1801</code>. The Characteristic <code>00002a05-0000-1000-8000-00805f9b34fb</code> is defined as &quot;Service Changed&quot;, and may be shortened as <code>0x2a05</code>.</p>
<a class="header" href="print.html#actions-on-characteristics" id="actions-on-characteristics"><h2>Actions on Characteristics</h2></a>
<p>There are specific actions which each Characteristic may or may not support. There are six main interactions:</p>
<a class="header" href="print.html#read" id="read"><h3>Read</h3></a>
<p>A <strong>Read</strong> is requested by the Client, and the Server retrieves the relevant data. Responses are limited to a single packet, typically about 20 bytes of data or less.</p>
<a class="header" href="print.html#write" id="write"><h3>Write</h3></a>
<p>A <strong>Write</strong> sends data to the Client, and the Server accepts the data. Writes are also limited to a single packet, typically about 20 bytes of data or less.</p>
<a class="header" href="print.html#long-read" id="long-read"><h3>Long Read</h3></a>
<p><strong>Long Read</strong>s are a procedure of breaking a larger data transmission into multiple parts, with each part containing data and an offset.</p>
<a class="header" href="print.html#long-write" id="long-write"><h3>Long Write</h3></a>
<p><strong>Long Write</strong>s are a procedure of breaking a larger data transmission into multiple parts, with each part containing data and an offset.</p>
<a class="header" href="print.html#notify" id="notify"><h3>Notify</h3></a>
<p>Rather than requiring a Client to poll a <strong>Read</strong> characteristic to obtain updated data, Bluetooth allows a Client to request a Server to <strong>Notify</strong> it whenever the data changes. The Bluetooth Server may then send data to all subscribed Clients asynchronously. <strong>Notify</strong> messages are also limited to the 20-byte data limit.</p>
<p><strong>Notify</strong> is particularly useful for low power devices, as it does not require the Server to be continually listening for requests from the Client.</p>
<a class="header" href="print.html#indicate-subscribe-w-ack" id="indicate-subscribe-w-ack"><h3>Indicate (subscribe w/ ACK)</h3></a>
<p><strong>Indicate</strong> is similar to <strong>Notify</strong>, however <strong>Indicate</strong> requires the Client to acknowledge the reception of the message.</p>
<a class="header" href="print.html#mqtt-and-other-iot-protocols" id="mqtt-and-other-iot-protocols"><h1>MQTT and other IoT Protocols</h1></a>
<p>For lightweight IoT devices, it can be difficult to implement protocols like HTTP commonly used in web applications, due to Memory, CPU, or Code Size limitations. Additionally, common behavior for IoT devices such as asynchronously sending updates or subscribing to updates of incoming data, are not well suited to traditional HTTP or REST APIs.</p>
<p>This has led to the development of protocols such as <a href="https://en.wikipedia.org/wiki/MQTT">MQTT</a>, <a href="https://en.wikipedia.org/wiki/Constrained_Application_Protocol">CoAP</a>, and <a href="https://en.wikipedia.org/wiki/OMA_LWM2M">LWM2M</a>, which address the complexity concerns, as well as behavior mismatch concerns. These protocols are primarily designed for Machine to Machine (M2M) communication, as opposed to HTTP, which is typically used for presentation of human readable information.</p>
<p>As these protocols have become commonly used by lightweight IoT devices, they have also become commonly used by devices without constraints, for interoperability purposes.</p>
<a class="header" href="print.html#mqtt" id="mqtt"><h2>MQTT</h2></a>
<p>MQTT is an application protocol that operates over TCP/IP, and allows devices to Subscribe and Publish to Topics. Devices act as MQTT Clients, and connect to a central MQTT Broker, which manages connections and dispatches messages to all connected MQTT Clients.</p>
<p>Similarly to HTTP, MQTT can be used directly over TCP, or may be secured using SSL/TLS. When the TCP connection used to connect to the MQTT Broker is secured with SSL/TLS, it is referred to as MQTTS.</p>
<a class="header" href="print.html#topics" id="topics"><h3>Topics</h3></a>
<p>Topics are represented as UTF-8 strings, and are composed of one or more Topic Levels, separated by the <code>/</code> character. Some examples of topics could include:</p>
<ul>
<li><code>home/james/kitchen/temperature/window</code></li>
<li><code>home/james/kitchen/temperature/oven</code></li>
<li><code>home/james/kitchen/brightness/window</code></li>
<li><code>home/niklas/livingroom/temperature/couch</code></li>
<li><code>home/niklas/kitchen/brightness/window</code></li>
<li><code>office/geeny/kitchen/temperature/window</code></li>
<li><code>office/geeny/kitchen/temperature/table</code></li>
</ul>
<a class="header" href="print.html#publishing" id="publishing"><h3>Publishing</h3></a>
<p>When an MQTT client would like to send data, it Publishes the data to a specific topic. The format of the payload, or data, is implementation defined, and is often either binary packed data (for size concerns), or JSON (for ease of use).</p>
<p>MQTT Clients do not talk directly to eachother, instead they send data to the MQTT Broker on a specific topic, which is broadcasted to all Clients which have subscribed to that topic.</p>
<p>For example, James' Kitchen Temperature Sensor might send the following information:</p>
<p>Topic: <code>home/james/kitchen/temperature/window</code></p>
<p>Data:</p>
<pre><code class="language-JSON">{
    &quot;temperature_celsius&quot;: 22.0
}
</code></pre>
<a class="header" href="print.html#subscribing" id="subscribing"><h3>Subscribing</h3></a>
<p>When an MQTT client would like to receive data, it subscribes to a topic. When a message is sent from the Broker to the Client, it contains the Topic as well as the payload. Topics may be specific, such as <code>home/james/kitchen/temperature/window</code>, or may include wildcards.</p>
<a class="header" href="print.html#wildcards" id="wildcards"><h4>Wildcards</h4></a>
<p>There are two kinds of subscription wildcards, Single Level, and Multi level.</p>
<p>A single level wildcard is represented as a <code>+</code> character. The subscription request for <code>home/+/kitchen/brightness/window</code> would match:</p>
<ul>
<li><code>home/james/kitchen/brightness/window</code></li>
<li><code>home/niklas/kitchen/brightness/window</code></li>
</ul>
<p>A multi level wildcard is represented as a <code>#</code> character. The subscription request for <code>#/temperature/window</code> would match:</p>
<ul>
<li><code>home/james/kitchen/temperature/window</code></li>
<li><code>office/geeny/kitchen/temperature/window</code></li>
</ul>
<p>These wildcards can be repeated and combined in a single subscription request. The subscription request for <code>#/temperature/+</code> would match all of :</p>
<ul>
<li><code>home/james/kitchen/temperature/window</code></li>
<li><code>home/james/kitchen/temperature/oven</code></li>
<li><code>home/niklas/livingroom/temperature/couch</code></li>
<li><code>office/geeny/kitchen/temperature/window</code></li>
<li><code>office/geeny/kitchen/temperature/table</code></li>
</ul>
<a class="header" href="print.html#quality-of-service" id="quality-of-service"><h3>Quality of Service</h3></a>
<p>MQTT allows for varying levels of guarantees regarding delivery of messages. There are three levels that can be chosen:</p>
<ul>
<li>QoS Level 0: At Most Once</li>
<li>QoS Level 1: At Least Once</li>
<li>QoS Level 2: Exactly Once</li>
</ul>
<p>As the QoS level rises, so does the amount of overhead. QoS Level 0 message require no acknowledgement from the Broker, QoS Level 1 requires a single acknowledgement from the Broker, and QoS Level 2 requires a four part handshake before a message has completed sending.</p>
<p>For periodic messages, such as a regular temperature reading, it may not be necessary to confirm reception (since additional messages will be sent), so QoS 0 would be a good match. For important messages that do not have side effects if applied multiple times, such as a &quot;stop motor&quot; command, QoS Level 1 would be a good match. For messages that must be received exactly once, such as &quot;increase temperature 5 degrees&quot;, QoS 2 should be used.</p>
<a class="header" href="print.html#coap-and-other-technologies" id="coap-and-other-technologies"><h2>CoAP and other technologies</h2></a>
<p>Other protocols have also been created to address many of the same topics addressed by MQTT. For example, CoAP was designed to operate similarly to how REST APIs work, with two major changes:</p>
<ul>
<li>UDP is used rather than TCP. This allows for reduced implementation requirements when compared to TCP.</li>
<li>CoAP introduces a SUBSCRIBE verb, which allows for asynchronus updates</li>
</ul>
<a class="header" href="print.html#cross-compilation" id="cross-compilation"><h1>Cross Compilation</h1></a>
<p>When developing software in a desktop or server context, the <strong>Target</strong> environment (where the software runs) is usually the same, or similar, to the <strong>Host</strong> environment (where the software is built/compiled). For interpreted languages, like Python, this is not a problem, as the local interpreter manages the differences. For compiled languages, it is necessary to have a compiler capable of running on the <strong>Host</strong> environment, but produce a binary usable on the <strong>Target</strong> environment.</p>
<p>For compilers like GCC, it is necessary to have a specific set of compiler tools built for the (<strong>Host</strong>, <strong>Target</strong>) set. Other compilers like LLVM (which Rust is built on top of), support multiple <strong>Target</strong>s with the same compiler.</p>
<p>Rust officially supports a number of platforms, with different levels of guaranteed functionality. A list of these platforms can be found in the official <a href="https://forge.rust-lang.org/platform-support.html">Rust Platform Documentation</a>.</p>
<a class="header" href="print.html#triples" id="triples"><h2>Triples</h2></a>
<p>When talking about Hosts and Targets, we typically refer to each of them based on a &quot;Triple&quot;, which is a short description of the CPU Architecture, the operating system, and any specific capabilities the platform supports. Definitions of triples vary a bit between LLVM and GCC, though we will mainly use the LLVM version.</p>
<p>A Host with an x86-64 CPU processor, running Linux, using glibc would have a triple of <code>x86_64-unknown-linux-gnu</code> (the &quot;unknown&quot; part here means there is no distribution specific assumptions made, and should work on any Linux system). If the Host were to use MUSL instead of glibc, it would have a triple of <code>x86_64-unknown-linux-musl</code>.</p>
<p>A target with an ARMv7 processor, running Linux, using glibc with hardware float support would have a triple of <code>armv7-unknown-linux-gnueabihf</code>.</p>
<a class="header" href="print.html#something-similar---armv7hf" id="something-similar---armv7hf"><h2>Something Similar - ARMv7HF</h2></a>
<p>When compiling for the Raspberry Pi, our Host and Target are generally similar. They are both running Linux, which abstracts away much of the low level interactions with the system. Rust and LLVM know how to compile code for the Raspberry Pi, however, compiling your code is only one part of the story.</p>
<a class="header" href="print.html#what-rust-can-do-and-what-it-cant" id="what-rust-can-do-and-what-it-cant"><h3>What Rust can do, and what it can't</h3></a>
<a class="header" href="print.html#rust-toolchains" id="rust-toolchains"><h4>Rust Toolchains</h4></a>
<p>When compiling your code, there are typically two &quot;implicit&quot; libraries used. <code>core</code>, and <code>std</code>.</p>
<p><code>core</code> contains very low level abstractions for interacting with primitive types like <code>u32</code> and <code>i64</code>, use of types like <code>str</code> and <code>slice</code>s, <code>Result</code> and <code>Option</code> types, and more.</p>
<p><code>std</code> contains higher level functionality, such as Heap allocated datatypes including <code>String</code> and <code>Vec</code>, <code>collection</code>s like <code>HashMap</code> and <code>BTree</code>, <code>thread</code>s, and even macros like <code>println!()</code>.</p>
<p>Instead of compiling components from <code>core</code> and <code>std</code> on every build, these components are generated as pre-built libraries, and linked into your application as necessary to save time. These components, when put together are called a <code>toolchain</code>.</p>
<p>In order to compile for a target, you will need to obtain a toolchain for that target. The toolchain is only specific to the target, so different hosts can use the same target toolchain.</p>
<p>If you have installed Rust using <code>rustup</code>, adding a an officially supported target is as simple as:</p>
<pre><code class="language-bash">rustup target add armv7-unknown-linux-gnueabihf
</code></pre>
<a class="header" href="print.html#linking" id="linking"><h4>Linking</h4></a>
<p>Currently, Rust does not use LLVM's linker, called <code>lld</code>. There is <a href="https://github.com/rust-lang/rust/issues/39915">current work</a> to change this, but it is still a work in progress. In the meantime, Rust uses the GCC linker, <code>ld</code>. Unfortunately as mentioned above, GCC tools (including <code>ld</code>) are specfic to a set of (<code>Host</code> and <code>Target</code>). This means it is necessary to install a GCC toolchain for the Host and Target for your cross compilation.</p>
<a class="header" href="print.html#not-every-crate-is-pure-statically-linked-rust" id="not-every-crate-is-pure-statically-linked-rust"><h3>Not every crate is pure, statically linked Rust!</h3></a>
<p>Some crates are used for wrapping existing C or C++ libraries. When compiling these crates, it is necessary to have a C/C++ compiler for the core of those libraries.</p>
<p>Other crates are used for wrapping Dynamically Linked Libraries, like OpenSSL or DBus. Care must be taken when compiling these libraries that the Host Environment and the Target Environment match, or the host is properly configured for the target.</p>
<a class="header" href="print.html#something-different---arm-cortex-m" id="something-different---arm-cortex-m"><h2>Something Different - ARM Cortex-M</h2></a>
<p>Cross compiling for embedded targets, like our Hail board, is a bit different.</p>
<a class="header" href="print.html#std-vs-core" id="std-vs-core"><h3><code>std</code> vs <code>core</code></h3></a>
<p>For embedded</p>
<a class="header" href="print.html#xargo---building-core-from-scratch" id="xargo---building-core-from-scratch"><h3>xargo - building <code>core</code> from scratch</h3></a>
<a class="header" href="print.html#cross--xargo" id="cross--xargo"><h3>cross + xargo</h3></a>
<ul>
<li>pain free embedded compilation</li>
</ul>
<a class="header" href="print.html#raspberry-pi-and-embedded-linux" id="raspberry-pi-and-embedded-linux"><h1>Raspberry Pi and Embedded Linux</h1></a>
<a class="header" href="print.html#typical-way-of-generating-firmware" id="typical-way-of-generating-firmware"><h2>Typical way of generating firmware</h2></a>
<a class="header" href="print.html#what-were-doing" id="what-were-doing"><h2>What we're doing</h2></a>
<a class="header" href="print.html#the-hail-board-and-tock-os" id="the-hail-board-and-tock-os"><h1>The Hail Board and Tock OS</h1></a>
<a class="header" href="print.html#introduction-and-overview" id="introduction-and-overview"><h2>Introduction and Overview</h2></a>
<a class="header" href="print.html#architecture-1" id="architecture-1"><h2>Architecture</h2></a>
<a class="header" href="print.html#kernel" id="kernel"><h3>Kernel</h3></a>
<a class="header" href="print.html#capsule" id="capsule"><h3>Capsule</h3></a>
<a class="header" href="print.html#process" id="process"><h3>Process</h3></a>
<a class="header" href="print.html#tock-os-work" id="tock-os-work"><h1>Tock OS Work</h1></a>
<ol>
<li>Print to console</li>
<li>Read from environmental sensors</li>
<li>Toggle LEDs</li>
<li>Bluetooth</li>
</ol>
<p>Useful items:</p>
<ul>
<li>nRF Connect application
<ul>
<li>https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&amp;hl=en</li>
<li>https://itunes.apple.com/de/app/nrf-connect/id1054362403?mt=8</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#hello-world" id="hello-world"><h1>Hello, World!</h1></a>
<a class="header" href="print.html#a-little-setup" id="a-little-setup"><h2>A little setup</h2></a>
<blockquote>
<p>Having trouble with the setup? Don't hesitate to ask for help!</p>
</blockquote>
<p>Open up the VM, make yourself comfortable. Sorry for the <code>en-us</code> environment and keyboard.</p>
<p>You can choose to either interact with the graphic environment, or you can SSH into the virtual machine. If you want to SSH, don't forget to foreward the port from host to the virtual machine. SSH is served up on the VM's port 22.</p>
<ul>
<li>Username: <code>rustfest</code></li>
<li>Password: <code>rustfest</code></li>
</ul>
<p>Now would also be a good time to add your SSH public key to the VM's <code>~/.ssh/authorized_keys</code>, and add an entry into your SSH config <code>~/.ssh/config</code> that looks like this:</p>
<pre><code class="language-text">host rustfest
    Hostname localhost
    User rustfest
    IdentityFile /home/$YOU/.ssh/id_rsa
    Port $MAPPED_PORT
</code></pre>
<p>This will save you some typing, but is completely optional.</p>
<a class="header" href="print.html#hello-host" id="hello-host"><h2>Hello, Host!</h2></a>
<p>Lets make a new project</p>
<pre><code class="language-bash">cargo new --bin hello-raspberry
cd hello-raspberry
</code></pre>
<p>Now lets compile and run it here</p>
<pre><code class="language-bash">cargo build
cargo run
</code></pre>
<p>You should get something like this:</p>
<pre><code class="language-text">rustfest@rustfest-2017:~/hello-raspberry$ cargo build
   Compiling hello-raspberry v0.1.0 (file:///home/rustfest/hello-raspberry)
    Finished dev [unoptimized + debuginfo] target(s) in 0.74 secs

rustfest@rustfest-2017:~/hello-raspberry$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello-raspberry`
Hello, world!
</code></pre>
<p>Lets look a bit closer at what we've done. We can use the <code>file</code> command to see what type of executable we've generated, and the <code>ldd</code> command to see what dynamic libraries we link to:</p>
<pre><code class="language-bash">file target/debug/hello-raspberry
ldd target/debug/hello-raspberry
</code></pre>
<a class="header" href="print.html#hello-target" id="hello-target"><h2>Hello, Target!</h2></a>
<p>Now lets build for the Raspberry Pi. Remember, the target triple we want here is <code>armv7-unknown-linux-gnueabihf</code>. This is normally done like this:</p>
<pre><code class="language-bash">cargo build --target armv7-unknown-linux-gnueabihf
</code></pre>
<p>Give it a try!</p>
<p>Back yet?</p>
<p>Yeah, it didn't work. We haven't given Cargo enough information. Lets check out the file <code>~/pi-crossenv</code>. Print it out with this command:</p>
<pre><code class="language-bash">cat ~/pi-crossenv
</code></pre>
<p>These are the important lines (for now):</p>
<pre><code class="language-text">export CARGO_TARGET_ARMV7_UNKNOWN_LINUX_GNUEABIHF_LINKER=arm-linux-gnueabihf-gcc
export CC_armv7_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc
export CXX_armv7_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++
</code></pre>
<p>These lines tell Cargo what C Compiler, C++ Compiler, and Linker to use when compiling for the <code>armv7-unknown-linux-gnueabihf</code> target.</p>
<p>Lets add these variables to our environment with the <code>source</code> command.</p>
<pre><code class="language-bash">source ~/pi-crossenv
</code></pre>
<p>Now we can retry cross compiling.</p>
<pre><code class="language-bash">cargo build --target armv7-unknown-linux-gnueabihf
</code></pre>
<p>This time you should see something like this:</p>
<pre><code class="language-text">rustfest@rustfest-2017:~/hello-raspberry$ cargo build --target armv7-unknown-linux-gnueabihf
   Compiling hello-raspberry v0.1.0 (file:///home/rustfest/hello-raspberry)
    Finished dev [unoptimized + debuginfo] target(s) in 0.70 secs
</code></pre>
<p>Lets check out the generated binary with <code>file</code>:</p>
<pre><code class="language-bash">file target/armv7-unknown-linux-gnueabihf/debug/hello-raspberry
</code></pre>
<p>How does that look compared to our other binary?</p>
<a class="header" href="print.html#hello-raspberry" id="hello-raspberry"><h2>Hello, Raspberry</h2></a>
<p>Now, lets log on to your Raspberry Pi. There are only 5 of them, so you might have to share.</p>
<p>You should have gotten the IP address of your Raspberry Pi on a post-it note. Lets login, and create a directory for you to work in.</p>
<ul>
<li>Username: <code>pi</code></li>
<li>Password: <code>internetofthings</code></li>
</ul>
<pre><code class="language-bash">ssh pi@&lt;IP ADDRESS&gt;

mkdir &lt;YOUR NAME&gt;
</code></pre>
<p>Now you should be able to send the file to your Raspberry Pi. From the VM:</p>
<pre><code class="language-bash">scp \
    target/armv7-unknown-linux-gnueabihf/debug/hello-raspberry \
    pi@&lt;IP ADDRESS&gt;:/home/pi/&lt;YOUR NAME&gt;
</code></pre>
<p>Finally, we should be able to log in, and run our application!</p>
<pre><code class="language-bash">ssh pi@&lt;IP ADDRESS&gt;
cd &lt;YOUR NAME&gt;
./hello-raspberry
</code></pre>
<p>If it all worked, you should see something like this:</p>
<pre><code class="language-text">pi@raspberrypi:~/james $ ./hello-raspberry
Hello, world!
</code></pre>
<a class="header" href="print.html#talking-with-bluetooth" id="talking-with-bluetooth"><h1>Talking with Bluetooth</h1></a>
<p>Before we get started, you'll need a Tock board. On the bottom, there should be a sticker with a MAC address that looks like <code>AA:BB:CC:DD:EE:FF</code>. We'll need this later.</p>
<p>If you're using the default Tock firmware, you'll also need to know the Service and Characteristics you want to interact with. These are probably:</p>
<ul>
<li>Service: <code>00001801-0000-1000-8000-00805f9b34fb</code>
<ul>
<li>Characteristic: <code>00002a05-0000-1000-8000-00805f9b34fb</code></li>
</ul>
</li>
</ul>
<p>To start off, we'll be using a crate called <code>easy-bluez</code>, which exposes the ability to read and write to Bluetooth Low Energy devices. This crate automatically handles the scanning, connection, and polling of the characteristics of your choosing. Under the hood, <code>easy-bluez</code> uses a crate called <code>blurz</code> to interact with Linux's <code>BlueZ</code> service over <code>dbus</code>.</p>
<a class="header" href="print.html#a-quick-reminder" id="a-quick-reminder"><h2>A quick reminder</h2></a>
<p>There were some other lines in <code>~/pi-crossenv</code> that we skipped over, particularly:</p>
<pre><code class="language-text">export SYSROOT=/raspi_stretch
export RPI_USR_LIB_DIR=${SYSROOT}/usr/lib/arm-linux-gnueabihf
export RPI_LIB_DIR=${SYSROOT}/lib/arm-linux-gnueabihf

export PKG_CONFIG_PATH=${RPI_USR_LIB_DIR}/pkgconfig
export PKG_CONFIG_LIBDIR=${RPI_USR_LIB_DIR}/pkgconfig:/usr/share/pkgconfig
export PKG_CONFIG_SYSROOT_DIR=${SYSROOT}
export PKG_CONFIG_ALLOW_CROSS=1
export RUSTFLAGS=&quot;-L ${RPI_USR_LIB_DIR} -L ${RPI_LIB_DIR} -lsystemd&quot;
</code></pre>
<p>Since <code>easy-bluez</code> uses DBus under the hood to talk to BlueZ, it is necessary to dynamically link to <code>libdbus-1</code>, and its dependencies. Since we want to make sure that our cross compilation environment matches our target, we've set up a <code>SYSROOT</code> at <code>/raspi_stretch</code>. This is a simulated version of the root filesystem found on our Raspberry Pis. This was populated using a tool called <code>multistrap</code>, which installs debian packages from other architectures to a specified location.</p>
<p>These environment variables instruct Cargo where to look for dynamically linked libraries, which are checked at compile time.</p>
<a class="header" href="print.html#set-up-easy-bluez" id="set-up-easy-bluez"><h2>Set up <code>easy-bluez</code></h2></a>
<p>Lets set up a new project inside the VM</p>
<pre><code class="language-bash">cd ~
cargo new --bin hello-bluetooth
cd hello-bluetooth
</code></pre>
<p>Now, lets add <code>easy-bluez</code> as a dependency, and make sure everything still builds. Add these lines to your <code>Cargo.toml</code>:</p>
<pre><code class="language-text">[dependencies]
easy-bluez = &quot;0.1&quot;
</code></pre>
<p>In your <code>src/main.rs</code>, add these lines:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate easy_bluez;
use easy_bluez::EasyBluez;

fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Now we're ready to compile! Don't forget to <code>source ~/pi-crossenv</code> if you've closed your window. After a bit of compiling, you should see something like this:</p>
<pre><code class="language-text">...
   Compiling hello-bluetooth v0.1.0 (file:///home/rustfest/hello-bluetooth)
warning: unused import: `easy_bluez::EasyBluez`
 --&gt; src/main.rs:2:5
  |
2 | use easy_bluez::EasyBluez;
  |     ^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_imports)] on by default
    Finished dev [unoptimized + debuginfo] target(s) in 59.69 secs
rustfest@rustfest-2017:~/hello-bluetooth$
</code></pre>
<p>If you don't see something like this, ask for help!</p>
<a class="header" href="print.html#read-from-your-hail-board" id="read-from-your-hail-board"><h2>Read from your Hail board</h2></a>
<p>Okay, lets actually read from your device. <code>easy-bluez</code> has a method called <code>poll</code>, which you can use like this:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate easy_bluez;
use easy_bluez::EasyBluez;

fn main() {
    let ez = EasyBluez::new().run();

    let rx_poll = ez.poll(
        &quot;CF:75:CE:86:6D:02&quot;,                    // MAC Address
        &quot;00000001-c001-de30-cabb-785feabcd123&quot;, // Service
        &quot;0000c01d-c001-de30-cabb-785feabcd123&quot;, // Characteristic
    ).expect(&quot;Bad data!&quot;);

    // Blocking wait for a message to be received
    if let Ok(msg) = rx_poll.recv() {
        println!(&quot;{:?}&quot;, msg);
    }
}
</code></pre></pre>
<p><code>poll</code> returns a <code>Result&lt;Receiver&lt;Box&lt;[u8]&gt;&gt;&gt;</code>, which will provide you with a stream of data obtained from the device, exposed as heap-allocated arrays of bytes.</p>
<p>Try building this code, and running it on your Raspberry Pi. As a note, <code>sudo</code> is required to interact with BlueZ, so you will need to run your binary with <code>sudo ./hello-bluetooth</code>. Don't forget to use your MAC Address, Service, and Characteristic!</p>
<p>Once you are able to read a single message, check out the documentation for <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html">Receiver<T></a>, and try processing messages as they arrive.</p>
<a class="header" href="print.html#write-to-your-hail-board" id="write-to-your-hail-board"><h2>Write to your Hail board</h2></a>
<p><code>easy-bluez</code> has another method called <code>writeable()</code>, which can be used like this:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate easy_bluez;
use easy_bluez::EasyBluez;
use std::time::Duration;
use std::thread::sleep;

fn main() {
    let ez = EasyBluez::new().run();

    let tx_write = ez.writeable(
        &quot;CF:75:CE:86:6D:02&quot;,                    // MAC Address
        &quot;00000001-c001-de30-cabb-785feabcd123&quot;, // Service
        &quot;0000da7a-c001-de30-cabb-785feabcd123&quot;, // Characteristic
    ).expect(&quot;Bad data!&quot;);

    // Send a single message to the device
    tx_write.send(Box::new([0x00])).unwrap();

    // Sleep for a bit to prevent returning before the message is sent
    sleep(Duration::from_secs(1));
}
</code></pre></pre>
<p>Try building this code, and running on your Raspberry Pi.</p>
<a class="header" href="print.html#putting-it-together" id="putting-it-together"><h2>Putting it together</h2></a>
<p>Once you have reading and writing working, try combining them!</p>
<p>For example, you could:</p>
<ul>
<li>Write a message every 4th receive</li>
<li>Send messages at a fixed interval, while processing all incoming messages</li>
</ul>
<a class="header" href="print.html#talking-to-the-cloud" id="talking-to-the-cloud"><h1>Talking to the Cloud</h1></a>
<p>It's time to start talking with the Internet! For this exercise, we will be using a publicly available MQTT Broker provided by Hive MQ to demonstrate some basic functionality. We'll be using a library called <a href="https://docs.rs/rumqtt/0.10.0/rumqtt/">rumqtt</a> to communicate as an MQTT Client.</p>
<p>Lets make a new project, and add <code>rumqtt</code> to it. In your Virtual Machine:</p>
<pre><code class="language-bash">cargo new --bin hello-mqtt
</code></pre>
<p>In your Cargo.toml:</p>
<pre><code>[dependencies]
rumqtt = &quot;0.10&quot;
</code></pre>
<p>In your <code>src/main.rs</code></p>
<pre><code>extern crate rumqtt;
</code></pre>
<a class="header" href="print.html#interact-over-mqtt" id="interact-over-mqtt"><h2>Interact over MQTT</h2></a>
<p>For easy debugging, we'll use HiveMQ's <a href="http://www.hivemq.com/demos/websocket-client/">Live Dashboard</a>. You can open a browser window here, and press &quot;Connect&quot;. You will be able to add subscription topics, as well as send messages to topics.</p>
<p>You will be able to connect to the same server using <code>rumqtt</code>, and see all messages sent back and forth</p>
<blockquote>
<p>WARNING: This is a publically used server, and is typically very busy with people sending all kinds of junk (and non-junk) data. Be careful when subscribing to wildcard topics with either <code>+</code> or <code>#</code>. I suggest using a path something like:</p>
<p><code>rustfest/YOUR_NAME/foo/bar</code></p>
</blockquote>
<a class="header" href="print.html#sending-messages" id="sending-messages"><h2>Sending Messages</h2></a>
<p>We'll start off with sending messages. Here is an example of connecting to the broker mentioned above, and sending a single message. You should see the message appear in the <a href="http://www.hivemq.com/demos/websocket-client/">Live Dashboard</a> window.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rumqtt;
use std::time::Duration;
use std::thread::sleep;
fn main() {

    let opts = rumqtt::MqttOptions::new()
        .set_broker(&quot;broker.mqttdashboard.com:1883&quot;)
        .set_client_id(&quot;demo-mqtt&quot;)
        .set_keep_alive(5)
        .set_reconnect(10);

    let mut client = rumqtt::MqttClient::start(opts, None).unwrap();

    client
        .publish(
            &quot;rustfest/james/demo&quot;,
            rumqtt::QoS::Level0,
            String::from(&quot;Hello, MQTT!&quot;).into_bytes(),
        ).unwrap();

    // Give time for the message to be sent
    sleep(Duration::from_secs(3));
}
</code></pre></pre>
<a class="header" href="print.html#receiving-messages" id="receiving-messages"><h2>Receiving Messages</h2></a>
<p>Here is an example which allows you to listen incoming messages for 30 seconds. After starting this client, you should be able to send messages from the <a href="http://www.hivemq.com/demos/websocket-client/">Live Dashboard</a>, and have them appear on your client.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rumqtt;

use std::time::Duration;
use std::thread::sleep;

fn main() {
    // Configure the client
    let opts = rumqtt::MqttOptions::new()
        .set_broker(&quot;broker.mqttdashboard.com:1883&quot;)
        .set_client_id(&quot;james-demo-mqtt&quot;)
        .set_keep_alive(5)
        .set_reconnect(10);

    // Provide a callback for all incoming messages
    let msg_handler = rumqtt::MqttCallback::new().on_message(|message| {
        println!(&quot;- Topic: {}\n  Message: {}&quot;,
                message.topic.to_string(),
                String::from_utf8_lossy(message.payload.as_ref())
        );
    });

    // Start the client
    let mut client = rumqtt::MqttClient::start(opts, Some(msg_handler)).unwrap();

    // Subscribe to topics
    client.subscribe(vec![(&quot;rustfest/#&quot;, rumqtt::QoS::Level0)]).unwrap();

    // Give time for the message(s) to arrive
    sleep(Duration::from_secs(30));
}
</code></pre></pre>
<a class="header" href="print.html#a-quick-note-about-security" id="a-quick-note-about-security"><h2>A quick note about security</h2></a>
<p>In this demo we are using MQTT, rather than MQTTS. This is mainly due to the fact that the demonstration broker we are using does not support MQTTS.</p>
<p>It is always recommended to use SSL when possible, otherwise, all data and login credentials are sent and received in plain text. When using SSL, you can make the following changes to the client configuration:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let opts = rumqtt::MqttOptions::new()

    // Port 8883 is typically MQTTS
    .set_broker(&quot;broker.mqttdashboard.com:8883&quot;)

    // What certificates to validate the server with
    .set_ca(&quot;/etc/ssl/certs/ca-certificates.crt&quot;)

    // Force verification of the certificates
    .set_should_verify_ca(true)

    // Same as above
    .set_client_id(&quot;demo-mqtt&quot;)
    .set_keep_alive(5)
    .set_reconnect(10);
#}</code></pre></pre>
<a class="header" href="print.html#put-it-together" id="put-it-together"><h2>Put it together</h2></a>
<p>Try creating a client that responds to all incoming messages on the same topic.</p>
<p>If you have time, try sending and receiving data formatted as JSON using <a href="https://github.com/serde-rs/json">Serde JSON</a></p>
<a class="header" href="print.html#putting-it-together-1" id="putting-it-together-1"><h1>Putting it together</h1></a>
<p>As we're getting to the end of the guided period, there are a few tasks to try out without much guidance.</p>
<p>Give them a try, and feel free to ask for help if you need it!</p>
<a class="header" href="print.html#task-one-transparent-protocol-converter" id="task-one-transparent-protocol-converter"><h2>Task One: Transparent Protocol Converter</h2></a>
<p>For our Tock board, we would like to send all information received from the Environmental Sense Characteristic over MQTT. Additionally, we would like to take specific messages received over MQTT, and forward them to the LED control characteristic.</p>
<a class="header" href="print.html#task-two-more-than-one-tock" id="task-two-more-than-one-tock"><h2>Task Two: More than one Tock</h2></a>
<p>Repeat the steps of Task One, however support 2 or more Tock boards at the same time. When sending messages over MQTT, make sure that it is possible to determine where the messages came from. When receiving messages from MQTT, make sure that only the correct Tock device receives the message you sent.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
